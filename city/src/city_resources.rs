use crate::models::ruleset::tile::{ResourceSupplyList, ResourceType};
use crate::models::ruleset::unique::{StateForConditionals, UniqueType};
use crate::city::City;
use std::collections::HashMap;

pub struct CityResources;

impl CityResources {
    /// Returns ALL resources, city-wide and civ-wide
    pub fn get_resources_generated_by_city(
        city: &City,
        resource_modifiers: &HashMap<String, f32>,
    ) -> ResourceSupplyList {
        let mut city_resources = Self::get_resources_generated_by_city_not_including_buildings(
            city,
            resource_modifiers,
        );
        Self::add_city_resources_generated_from_unique_buildings(city, &mut city_resources, resource_modifiers);
        city_resources
    }

    /// Only for *city-wide* resources - civ-wide resources should use civ-level resources
    pub fn get_city_resources_available_to_city(city: &City) -> ResourceSupplyList {
        let mut resource_modifiers = HashMap::new();
        for resource in city.civ.game_info.ruleset.tile_resources.values() {
            resource_modifiers.insert(resource.name.clone(), city.civ.get_resource_modifier(resource));
        }

        let mut city_resources = Self::get_resources_generated_by_city_not_including_buildings(
            city,
            &resource_modifiers,
        );
        // We can't use get_resources_generated_by_city directly, because that would include the resources generated by buildings -
        //   which are part of the civ-wide uniques, so we'd be getting them twice!
        Self::get_city_resources_from_civ(city, &mut city_resources, &resource_modifiers);

        city_resources.retain(|r| r.resource.is_city_wide);

        city_resources
    }

    fn get_resources_generated_by_city_not_including_buildings(
        city: &City,
        resource_modifiers: &HashMap<String, f32>,
    ) -> ResourceSupplyList {
        let mut city_resources = ResourceSupplyList::new();

        Self::add_resources_from_tiles(city, resource_modifiers, &mut city_resources);
        Self::add_resource_from_unique_improved_tiles(city, &mut city_resources, resource_modifiers);
        Self::remove_city_resources_required_by_buildings(city, &mut city_resources);

        if city.civ.is_city_state && city.is_capital() && city.civ.city_state_resource.is_some() {
            if let Some(resource) = city.get_ruleset().tile_resources.get(&city.civ.city_state_resource.unwrap()) {
                city_resources.add(resource.clone(), "Mercantile City-State");
            }
        }

        city_resources
    }

    fn add_city_resources_generated_from_unique_buildings(
        city: &City,
        city_resources: &mut ResourceSupplyList,
        resource_modifier: &HashMap<String, f32>,
    ) {
        for unique in city.get_matching_uniques(UniqueType::ProvidesResources, &city.state, false) {
            if let Some(resource) = city.get_ruleset().tile_resources.get(&unique.params[1]) {
                let amount = (unique.params[0].parse::<f32>().unwrap_or(0.0)
                    * resource_modifier.get(&resource.name).unwrap_or(&1.0)) as i32;
                city_resources.add(resource.clone(), unique.get_source_name_for_user(), amount);
            }
        }
    }

    /// Gets the number of resources available to this city
    /// Accommodates both city-wide and civ-wide resources
    pub fn get_available_resource_amount(city: &City, resource_name: &str) -> i32 {
        let resource = match city.get_ruleset().tile_resources.get(resource_name) {
            Some(r) => r,
            None => return 0,
        };

        if !resource.is_city_wide {
            return city.civ.get_resource_amount(resource_name);
        }
        if resource.is_stockpiled {
            return city.resource_stockpiles.get(resource_name).copied().unwrap_or(0);
        }
        Self::get_city_resources_available_to_city(city)
            .iter()
            .filter(|r| r.resource == *resource)
            .map(|r| r.amount)
            .sum()
    }

    fn add_resources_from_tiles(
        city: &City,
        resource_modifier: &HashMap<String, f32>,
        city_resources: &mut ResourceSupplyList,
    ) {
        for tile_info in city.get_tiles().iter().filter(|t| t.resource.is_some()) {
            let resource = tile_info.tile_resource();
            let amount = Self::get_tile_resource_amount(city, tile_info)
                * resource_modifier.get(&resource.name).unwrap_or(&1.0);
            if amount > 0.0 {
                city_resources.add(resource, "Tiles", amount as i32);
            }
        }
    }

    fn add_resource_from_unique_improved_tiles(
        city: &City,
        city_resources: &mut ResourceSupplyList,
        resource_modifier: &HashMap<String, f32>,
    ) {
        for tile_info in city.get_tiles().iter().filter(|t| t.get_unpillaged_improvement().is_some()) {
            let state_for_conditionals = StateForConditionals::new(&city.civ, city, Some(tile_info));
            let tile_improvement = tile_info.get_unpillaged_tile_improvement().unwrap();

            for unique in tile_improvement.get_matching_uniques(UniqueType::ProvidesResources, &state_for_conditionals) {
                if let Some(resource) = city.get_ruleset().tile_resources.get(&unique.params[1]) {
                    let amount = (unique.params[0].parse::<f32>().unwrap_or(0.0)
                        * resource_modifier.get(&resource.name).unwrap_or(&1.0)) as i32;
                    city_resources.add(resource.clone(), "Improvements", amount);
                }
            }

            for unique in tile_improvement.get_matching_uniques(UniqueType::ConsumesResources, &state_for_conditionals) {
                if let Some(resource) = city.get_ruleset().tile_resources.get(&unique.params[1]) {
                    let amount = -1 * unique.params[0].parse::<i32>().unwrap_or(0);
                    city_resources.add(resource.clone(), "Improvements", amount);
                }
            }
        }
    }

    fn remove_city_resources_required_by_buildings(city: &City, city_resources: &mut ResourceSupplyList) {
        let free_buildings = city.civ.civ_constructions.get_free_building_names(city);
        for building in city.city_constructions.get_built_buildings() {
            // Free buildings cost no resources
            if free_buildings.contains(&building.name) {
                continue;
            }
            city_resources.subtract_resource_requirements(
                &building.get_resource_requirements_per_turn(&city.state),
                &city.get_ruleset(),
                "Buildings",
            );
        }
    }

    fn get_city_resources_from_civ(
        city: &City,
        city_resources: &mut ResourceSupplyList,
        resource_modifiers: &HashMap<String, f32>,
    ) {
        // This includes the uniques from buildings, from this and all other cities
        for unique in city.get_matching_uniques(UniqueType::ProvidesResources, &city.state) {
            if let Some(resource) = city.get_ruleset().tile_resources.get(&unique.params[1]) {
                let amount = (unique.params[0].parse::<f32>().unwrap_or(0.0)
                    * resource_modifiers.get(&resource.name).unwrap_or(&1.0)) as i32;
                city_resources.add(resource.clone(), unique.get_source_name_for_user(), amount);
            }
        }
    }

    fn get_tile_resource_amount(city: &City, tile: &Tile) -> f32 {
        let resource = match tile.resource {
            Some(ref r) => r,
            None => return 0.0,
        };

        if !tile.provides_resources(&city.civ) {
            return 0.0;
        }

        let mut amount_to_add = if resource.resource_type == ResourceType::Strategic {
            tile.resource_amount as f32
        } else {
            1.0
        };

        if resource.resource_type == ResourceType::Luxury
            && city.contains_building_unique(UniqueType::ProvidesExtraLuxuryFromCityResources)
        {
            amount_to_add += 1.0;
        }

        amount_to_add
    }
}