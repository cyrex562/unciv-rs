use std::collections::HashMap;
use bevy::prelude::*;
use bevy_egui::egui::{self, Frame};

use crate::models::ruleset::{Ruleset};
use crate::models::stats::INamed;
use crate::ui::screens::civilopediascreen::formatted_line::FormattedLine;
use crate::ui::screens::civilopediascreen::markup_renderer::MarkupRenderer;
use crate::ui::screens::civilopediascreen::simple_civilopedia_text::SimpleCivilopediaText;
use crate::ui::objectdescriptions::uniques_to_civilopedia_text_lines;
use crate::UncivGame;

/// Trait for objects that can be displayed in the Civilopedia.
///
/// This trait is implemented by most ruleset game objects to manage civilopedia display.
///
/// ### Usage:
/// 1. Let [Ruleset] object implement this (by inheriting and implementing trait [ICivilopediaText])
/// 2. Add `"civilopediaText": ["",â€¦],` in the json for these objects
/// 3. Optionally override [get_civilopedia_text_header] to supply a different header line
/// 4. Optionally override [get_civilopedia_text_lines] to supply automatic stuff like tech prerequisites, uniques, etc.
/// 5. Optionally override [assemble_civilopedia_text] to handle assembly of the final set of lines yourself.
pub trait ICivilopediaText {
    /// List of strings supporting simple formatting rules that [CivilopediaScreen] can render.
    /// May later be merged with automatic lines generated by the deriving class
    /// through overridden [get_civilopedia_text_header] and/or [get_civilopedia_text_lines] methods.
    fn civilopedia_text(&self) -> Vec<FormattedLine>;

    /// Generate header line from object metadata.
    /// Default implementation will take [INamed.name] and render it in 150% normal font size with an icon from [make_link].
    ///
    /// Returns a [FormattedLine] that will be inserted on top
    fn get_civilopedia_text_header(&self) -> Option<FormattedLine> {
        if let Some(named) = self.as_any().downcast_ref::<dyn INamed>() {
            Some(FormattedLine::new()
                .with_text(named.name())
                .with_icon(self.make_link())
                .with_header(2))
        } else {
            None
        }
    }

    /// Generate automatic lines from object metadata.
    ///
    /// This function **MUST not rely** on [UncivGame::current().game_info]
    /// **or** [UncivGame::current().world_screen] being initialized,
    /// this should be able to run from the main menu.
    /// (And the info displayed should be about the **ruleset**, not the player situation)
    ///
    /// Default implementation is empty - no need to call super in overrides.
    /// Note that for inclusion of Uniques, two helpers named [uniques_to_civilopedia_text_lines] exist (for Sequence or MutableCollection context).
    ///
    /// # Arguments
    /// * `ruleset` - The current ruleset for the Civilopedia viewer
    ///
    /// Returns a list of [FormattedLine]s that will be inserted before
    /// the first line of [civilopedia_text] having a [link][FormattedLine::link]
    fn get_civilopedia_text_lines(&self, ruleset: &Ruleset) -> Vec<FormattedLine> {
        Vec::new()
    }

    /// Build a UI element showing our formatted content.
    ///
    /// # Arguments
    /// * `label_width` - The width of the label
    /// * `link_action` - Optional callback for link clicks
    ///
    /// Returns a UI element containing the rendered content
    fn render_civilopedia_text(&self, label_width: f32, link_action: Option<Box<dyn Fn(&str)>>) -> Frame {
        MarkupRenderer::render(&self.civilopedia_text(), label_width, link_action)
    }

    /// Assemble json-supplied lines with automatically generated ones.
    ///
    /// The default implementation will insert [get_civilopedia_text_lines] before the first [linked][FormattedLine::link] [civilopedia_text] line and [get_civilopedia_text_header] on top.
    ///
    /// # Arguments
    /// * `ruleset` - The current ruleset for the Civilopedia viewer
    ///
    /// Returns a new CivilopediaText instance containing original [civilopedia_text] lines merged with those from [get_civilopedia_text_header] and [get_civilopedia_text_lines] calls.
    fn assemble_civilopedia_text(&self, ruleset: &Ruleset) -> Box<dyn ICivilopediaText> {
        let mut new_lines = Vec::new();
        let mut middle_done = false;
        let mut outer_not_empty = false;

        // Add header if available
        if let Some(header) = self.get_civilopedia_text_header() {
            new_lines.push(header);
            new_lines.push(FormattedLine::new().with_separator());
        }

        // Process existing lines
        let outer_lines = self.civilopedia_text();
        for next in outer_lines {
            if !middle_done && !next.is_empty() && next.link_type() != crate::ui::screens::civilopediascreen::formatted_line::LinkType::None {
                middle_done = true;
                if outer_not_empty {
                    new_lines.push(FormattedLine::new());
                }
                new_lines.extend(self.get_civilopedia_text_lines(ruleset));
                new_lines.push(FormattedLine::new());
            }
            outer_not_empty = true;
            new_lines.push(next);
        }

        // Add remaining lines if needed
        if !middle_done {
            if outer_not_empty {
                new_lines.push(FormattedLine::new());
            }
            new_lines.extend(self.get_civilopedia_text_lines(ruleset));
        }

        // Add mod information if applicable
        if let Some(ruleset_obj) = self.as_any().downcast_ref::<Ruleset>() {
            if ruleset.mods.len() > 1 && !ruleset_obj.origin_ruleset().is_empty() {
                new_lines.push(FormattedLine::new());
                new_lines.push(FormattedLine::new()
                    .with_text(format!("Mod: [{}]", ruleset_obj.origin_ruleset()))
                    .with_starred()
                    .with_color("#daa520"));
            }
        }

        Box::new(SimpleCivilopediaText::new(new_lines))
    }

    /// Create the correct string for a Civilopedia link.
    ///
    /// To actually make it work both as link and as icon identifier, return a string in the form
    /// category/entryname where `category` **must** correspond exactly to either name or label of
    /// the correct [CivilopediaCategories] member. `entryname` must equal the
    /// [ruleset object name][RulesetObject] as defined by the [INamed] interface.
    fn make_link(&self) -> String;

    /// Overrides alphabetical sorting in Civilopedia
    ///
    /// # Arguments
    /// * `ruleset` - The current ruleset in case the function needs to do lookups
    ///
    /// Returns the sort group for this object
    fn get_sort_group(&self, ruleset: &Ruleset) -> i32 {
        0
    }

    /// Overrides Icon used for Civilopedia entry list (where you select the instance)
    /// This will still be passed to the category-specific image getter.
    fn get_icon_name(&self) -> String {
        if let Some(named) = self.as_any().downcast_ref::<dyn INamed>() {
            named.name().to_string()
        } else {
            String::new()
        }
    }

    /// Helper method to downcast to Any for type checking
    fn as_any(&self) -> &dyn std::any::Any;
}